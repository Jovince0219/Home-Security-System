{% extends "base.html" %}

{% block title %}Dashboard - Security System{% endblock %}

{% block content %}
<div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
    <!-- Live Camera Feed with Face Recognition -->
    <div class="lg:col-span-2">
        <div class="bg-white rounded-lg shadow-lg p-6">
            <h2 class="text-2xl font-bold mb-4 flex items-center">
                <i class="fas fa-camera mr-3 text-blue-600"></i>
                Live Camera Feed
            </h2>
            <div class="relative">
                <video id="videoElement" class="w-full h-64 bg-black rounded-lg" autoplay muted></video>
                <canvas id="overlayCanvas" class="absolute top-0 left-0 w-full h-64 pointer-events-none"></canvas>
                <div class="absolute top-2 right-2 bg-red-600 text-white px-2 py-1 rounded text-sm">
                    <i class="fas fa-circle mr-1"></i>LIVE
                </div>
                <!-- Enhanced face detection overlay with better fitting boxes -->
                <div id="faceOverlay" class="absolute top-0 left-0 w-full h-full pointer-events-none"></div>
            </div>

            <!-- Camera Controls -->
            <div class="mt-4 bg-gray-50 rounded-lg p-4">
                <h4 class="font-semibold mb-3">Camera Controls</h4>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-2">
                    <button id="startCamera"
                        class="bg-green-600 hover:bg-green-700 text-white px-3 py-2 rounded text-sm">
                        <i class="fas fa-camera mr-1"></i>Start Camera
                    </button>
                    <button id="stopCamera" class="bg-red-600 hover:bg-red-700 text-white px-3 py-2 rounded text-sm">
                        <i class="fas fa-stop mr-1"></i>Stop Camera
                    </button>
                    <button id="takeScreenshot"
                        class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-2 rounded text-sm">
                        <i class="fas fa-camera mr-1"></i>Screenshot
                    </button>
                </div>
                <div class="mt-3 text-sm text-gray-600">
                    <i class="fas fa-info-circle mr-1"></i>
                    Click "Start Camera" to activate your laptop's camera for face recognition
                </div>
            </div>

            <!-- Enhanced controls with quick actions -->
            <div class="mt-4 grid grid-cols-2 md:grid-cols-4 gap-2">
                <button id="toggleRecording"
                    class="bg-purple-600 hover:bg-purple-700 text-white px-3 py-2 rounded text-sm">
                    <i class="fas fa-record-vinyl mr-1"></i>Record
                </button>
                <button id="toggleMotionDetection"
                    class="bg-yellow-600 hover:bg-yellow-700 text-white px-3 py-2 rounded text-sm">
                    <i class="fas fa-running mr-1"></i>Motion Detection
                </button>
                <button onclick="toggleFaceRecognition()"
                    class="bg-indigo-600 hover:bg-indigo-700 text-white px-3 py-2 rounded text-sm">
                    <i class="fas fa-user-check mr-1"></i>Face Recognition
                </button>
                <button onclick="playQuickMessage('warning')"
                    class="bg-orange-600 hover:bg-orange-700= px-3 py-2 rounded text-sm">
                    <i class="fas fa-volume-up mr-1"></i>Warning
                </button>
            </div>
            <!-- Motion Detection Overlay -->
            <div id="motionOverlay" class="absolute top-0 left-0 w-full h-full pointer-events-none"></div>
        </div>
    </div>

    <!-- System Status -->
    <div class="space-y-6">
        <div class="bg-white rounded-lg shadow-lg p-6">
            <h3 class="text-lg font-bold mb-4 flex items-center">
                <i class="fas fa-heartbeat mr-2 text-green-600"></i>
                System Status
            </h3>
            <div class="space-y-3">
                <div class="flex justify-between items-center">
                    <span>Camera Feed</span>
                    <span id="cameraStatus" class="bg-red-100 text-red-800 px-2 py-1 rounded text-sm">Inactive</span>
                </div>
                <div class="flex justify-between items-center">
                    <span>Face Recognition</span>
                    <span id="faceRecognitionStatus"
                        class="bg-green-100 text-green-800 px-2 py-1 rounded text-sm">Active</span>
                </div>
                <div class="flex justify-between items-center">
                    <span>Motion Detection</span>
                    <span id="motionDetectionStatus"
                        class="bg-yellow-100 text-yellow-800 px-2 py-1 rounded text-sm">Inactive</span>
                </div>
                <div class="flex justify-between items-center">
                    <span>Recording</span>
                    <span id="recordingStatus" class="bg-red-100 text-red-800 px-2 py-1 rounded text-sm">Stopped</span>
                </div>
            </div>
        </div>

        <div class="bg-white rounded-lg shadow-lg p-6">
            <h3 class="text-lg font-bold mb-4 flex items-center">
                <i class="fas fa-chart-line mr-2 text-blue-600"></i>
                Today's Stats
            </h3>
            <div class="space-y-3" id="todayStats">
                <div class="flex justify-between">
                    <span>Face Detections</span>
                    <span class="font-bold">0</span>
                </div>
                <div class="flex justify-between">
                    <span>Motion Events</span>
                    <span class="font-bold">0</span>
                </div>
                <div class="flex justify-between">
                    <span>Alerts Sent</span>
                    <span class="font-bold">0</span>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Distance Settings Panel -->
<div class="mt-6 bg-white rounded-lg shadow-lg p-6">
    <div class="flex justify-between items-center mb-4">
        <h3 class="text-lg font-bold flex items-center">
            <i class="fas fa-ruler-combined mr-2 text-purple-600"></i>
            Distance Detection Settings
        </h3>
        <button onclick="toggleDistanceSettings()"
            class="bg-purple-600 hover:bg-purple-700 text-white px-3 py-1 rounded text-sm">
            <i class="fas fa-cog mr-1"></i>Configure
        </button>
    </div>

    <!-- Collapsible Settings Panel -->
    <div id="distanceSettingsPanel" class="hidden">
        <div class="bg-gray-50 rounded-lg p-4 space-y-4">
            <!-- Distance Thresholds -->
            <div>
                <label class="block text-sm font-semibold mb-2">
                    <i class="fas fa-expand-arrows-alt mr-1"></i>
                    Maximum Detection Distance (meters)
                </label>
                <input type="number" id="maxDistance" value="6.0" step="0.5" min="1" max="20"
                    class="w-full border rounded px-3 py-2">
                <p class="text-xs text-gray-600 mt-1">
                    Maximum distance at which faces will be detected and analyzed
                </p>
            </div>

            <!-- Save Button -->
            <button onclick="saveDistanceSettings()"
                class="w-full bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded font-semibold">
                <i class="fas fa-save mr-2"></i>Save Settings
            </button>
        </div>
    </div>
</div>

<script>
    function openCalibrationModal() {
        document.getElementById('calibrationModal').classList.remove('hidden');
    }

    function closeCalibrationModal() {
        document.getElementById('calibrationModal').classList.add('hidden');
    }

    function captureCalibrationFace() {
        if (!cameraStream) {
            alert('Please start the camera first');
            return;
        }

        const video = document.getElementById('videoElement');
        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0);

        const imageData = canvas.toDataURL('image/jpeg');

        // Send to server for calibration
        const knownDistance = document.getElementById('calibrationDistance').value;

        const formData = new FormData();
        formData.append('image_data', imageData);
        formData.append('known_distance', knownDistance);

        fetch('/api/estimate_distance', {
            method: 'POST',
            body: formData
        })
            .then(response => response.json())
            .then(data => {
                if (data.success && data.faces.length > 0) {
                    const face = data.faces[0];
                    const faceWidthPixels = face.location[1] - face.location[3];

                    // Now calibrate with this info
                    const calibFormData = new FormData();
                    calibFormData.append('known_distance', knownDistance);
                    calibFormData.append('face_width_pixels', faceWidthPixels);

                    return fetch('/api/calibrate_distance', {
                        method: 'POST',
                        body: calibFormData
                    });
                } else {
                    throw new Error('No face detected. Please ensure a face is visible.');
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    const resultDiv = document.getElementById('calibrationResult');
                    resultDiv.classList.remove('hidden');
                    resultDiv.innerHTML = `
                <i class="fas fa-check-circle text-green-600 mr-2"></i>
                <strong>Calibration successful!</strong><br>
                Focal length: ${data.focal_length.toFixed(2)}
            `;

                    setTimeout(() => {
                        closeCalibrationModal();
                    }, 3000);
                } else {
                    alert('Calibration failed: ' + data.error);
                }
            })
            .catch(error => {
                alert(error.message || 'Calibration error');
                console.error('Calibration error:', error);
            });
    }
</script>

<!-- Recent Unauthorized Detections -->
<div class="mt-6 bg-white rounded-lg shadow-lg p-6">
    <h3 class="text-lg font-bold mb-4 flex items-center">
        <i class="fas fa-exclamation-triangle mr-2 text-red-600"></i>
        Recent Security Alerts (Unauthorized Only)
    </h3>
    <div class="overflow-x-auto">
        <table class="min-w-full table-auto">
            <thead>
                <tr class="bg-gray-50">
                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Time</th>
                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Type</th>
                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Detection
                    </th>
                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                        Confidence</th>
                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Alert
                        Level</th>
                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Action
                    </th>
                </tr>
            </thead>
            <tbody id="detectionsTable">
                <!-- Detections will be loaded here -->
                <tr>
                    <td colspan="6" class="px-4 py-8 text-center text-gray-500">
                        <i class="fas fa-shield-check text-3xl mb-2 text-green-400"></i>
                        <p class="text-lg font-semibold">Loading security alerts...</p>
                    </td>
                </tr>
            </tbody>
        </table>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    // Face recognition state management
    let cameraStream = null;
    let isRecording = false;
    let faceRecognitionActive = true;
    let motionDetectionActive = true;
    let recognitionInterval = null;
    let detectionIntervalMs = 1000;
    let fpsCounter = 0;
    let lastFpsUpdate = Date.now();
    let motionDetectionInterval = null;

    // Motion-gated face recognition state
    let motionGatedRecognition = true;
    let lastMotionDetectionTime = null;
    let motionTimeout = 5000;

    // Face recognition queue system
    let isProcessingFaceRecognition = false;
    let faceRecognitionQueue = [];
    let pendingFaceRecognition = null;

    // Camera controls
    document.getElementById('startCamera').addEventListener('click', startCamera);
    document.getElementById('stopCamera').addEventListener('click', stopCamera);
    document.getElementById('takeScreenshot').addEventListener('click', takeScreenshot);
    document.getElementById('toggleRecording').addEventListener('click', toggleRecording);
    document.getElementById('toggleMotionDetection').addEventListener('click', toggleMotionDetection);

    async function startCamera() {
        try {
            cameraStream = await navigator.mediaDevices.getUserMedia({
                video: {
                    width: { ideal: 1280 },
                    height: { ideal: 720 },
                    facingMode: 'user'
                },
                audio: false
            });

            const videoElement = document.getElementById('videoElement');
            videoElement.srcObject = cameraStream;

            // Wait for video to be ready
            await new Promise((resolve) => {
                videoElement.onloadedmetadata = () => {
                    videoElement.play();
                    resolve();
                };
            });

            // Initialize overlay positioning
            initializeOverlay();
            updateCameraStatus('Active');

            cameraStream.getTracks().forEach(track => {
                track.onended = () => {
                    stopCamera();
                };
            });

            if (faceRecognitionActive) {
                startFaceRecognition();
            }

        } catch (error) {
            console.error('Error accessing camera:', error);
            if (error.name === 'NotAllowedError') {
                alert('Camera permission denied. Please allow camera access to continue.');
            } else if (error.name === 'NotFoundError') {
                alert('No camera found. Please check if your camera is connected and try again.');
            } else {
                alert('Could not start camera: ' + error.message);
            }
        }
    }

    function stopCamera() {
        if (cameraStream) {
            cameraStream.getTracks().forEach(track => track.stop());
            document.getElementById('videoElement').srcObject = null;
            cameraStream = null;

            stopFaceRecognition();
            document.getElementById('faceOverlay').innerHTML = '';
            updateCameraStatus('Inactive');
        }
    }

    function stopFaceRecognition() {
        if (recognitionInterval) {
            clearInterval(recognitionInterval);
            recognitionInterval = null;
        }

        // Clear any pending requests
        faceRecognitionQueue = [];
        isProcessingFaceRecognition = false;
        pendingFaceRecognition = null;
    }

    function startFaceRecognition() {
        if (recognitionInterval) return;

        console.log('Starting face recognition with queued system');

        recognitionInterval = setInterval(() => {
            // Instead of calling recognizeFaces directly, add to queue
            queueFaceRecognition();
        }, detectionIntervalMs);
    }

    // Queue-based face recognition
    function queueFaceRecognition() {
        const video = document.getElementById('videoElement');
        if (!video.srcObject || video.readyState !== video.HAVE_ENOUGH_DATA) {
            return;
        }

        // If we're already processing, just return
        if (isProcessingFaceRecognition) {
            return;
        }

        // Process immediately
        processFaceRecognition();
    }

    // Process face recognition one at a time
    async function processFaceRecognition() {
        if (isProcessingFaceRecognition) {
            return;
        }

        const video = document.getElementById('videoElement');
        if (!video.srcObject || video.readyState !== video.HAVE_ENOUGH_DATA) {
            return;
        }

        isProcessingFaceRecognition = true;

        try {
            await recognizeFaces();
        } catch (error) {
            console.error('Face recognition error:', error);
        } finally {
            // Use a small delay before allowing next processing to prevent rapid firing
            setTimeout(() => {
                isProcessingFaceRecognition = false;
            }, 100);
        }
    }

    function recognizeFaces() {
        return new Promise((resolve, reject) => {
            const video = document.getElementById('videoElement');
            if (!video.srcObject || video.readyState !== video.HAVE_ENOUGH_DATA) {
                reject(new Error('Video not ready'));
                return;
            }

            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0);

            const imageData = canvas.toDataURL('image/jpeg', 0.8);

            const endpoint = motionGatedRecognition ? '/api/recognize_faces_with_motion' : '/api/recognize_faces';

            const formData = new FormData();
            formData.append('image_data', imageData);

            fetch(endpoint, {
                method: 'POST',
                body: formData
            })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        displayFaceBoxes(data.faces);

                        // Display motion-only detection if present
                        if (data.motion_only_detection) {
                            displayMotionOnlyDetection(data.motion_only_detection);
                        }

                        // Update motion status indicator
                        if (data.motion_status) {
                            updateMotionStatusIndicator(data.motion_status);
                        }
                    }
                    resolve(data);
                })
                .catch(error => {
                    console.error('Face recognition error:', error);
                    reject(error);
                });
        });
    }

    function updateMotionStatusIndicator(status) {
        const indicator = document.getElementById('motionStatusIndicator');
        if (!indicator) return;

        let statusHTML = '';

        if (status.human_motion_detected) {
            statusHTML = `
            <i class="fas fa-running text-green-600"></i>
            <span class="text-green-600">Human Motion Active</span>
        `;
            lastMotionDetectionTime = Date.now();
        } else {
            const timeSinceMotion = lastMotionDetectionTime ?
                ((Date.now() - lastMotionDetectionTime) / 1000).toFixed(1) : 'N/A';

            statusHTML = `
            <i class="fas fa-ban text-red-600"></i>
            <span class="text-red-600">No Human Motion</span>
            <span class="text-sm text-gray-600">(Last motion: ${timeSinceMotion}s ago)</span>
        `;
        }

        // Add face detection status
        if (status.face_detection_enabled) {
            statusHTML += `
            <div class="text-xs text-green-600 mt-1">
                <i class="fas fa-user-check mr-1"></i>
                <strong>Face Detection:</strong> ACTIVE
            </div>
        `;
        } else {
            statusHTML += `
            <div class="text-xs text-gray-600 mt-1">
                <i class="fas fa-user-slash mr-1"></i>
                <strong>Face Detection:</strong> Waiting for human motion (authorized faces only)
            </div>
        `;
        }

        // Add motion-only alert status
        if (status.motion_only_alert) {
            statusHTML += `
            <div class="text-xs text-red-600 mt-1">
                <i class="fas fa-exclamation-triangle mr-1"></i>
                <strong>Motion-Only Alert:</strong> Triggered - No face detected
            </div>
        `;
        }

        // Add distance settings info
        if (status.distance_settings) {
            statusHTML += `
            <div class="text-xs text-gray-600 mt-1">
                <strong>Distance Settings:</strong> 
                Max: ${status.distance_settings.max_distance}m, 
                Warn: ${status.distance_settings.warning_distance}m, 
                Critical: ${status.distance_settings.critical_distance}m
            </div>
        `;
        }

        indicator.innerHTML = statusHTML;
    }

    function displayFaceBoxes(faces) {
        const overlay = document.getElementById('faceOverlay');
        const video = document.getElementById('videoElement');

        overlay.innerHTML = '';

        const videoRect = video.getBoundingClientRect();
        const videoAspectRatio = video.videoWidth / video.videoHeight;
        const displayAspectRatio = videoRect.width / videoRect.height;

        let scaleX, scaleY, offsetX = 0, offsetY = 0;

        if (displayAspectRatio > videoAspectRatio) {
            scaleY = videoRect.height / video.videoHeight;
            scaleX = scaleY;
            offsetX = (videoRect.width - (video.videoWidth * scaleX)) / 2;
        } else {
            scaleX = videoRect.width / video.videoWidth;
            scaleY = scaleX;
            offsetY = (videoRect.height - (video.videoHeight * scaleY)) / 2;
        }

        faces.forEach(face => {
            // Only display faces detected within critical distance
            // (The backend already filters, but double-check here)
            if (!face.within_detection_range && !face.is_authorized) {
                return;
            }

            const box = document.createElement('div');

            // Enhanced color coding
            let borderColor, bgColor, boxShadow;

            if (face.is_authorized) {
                borderColor = '#22c55e'; // Green for authorized
                bgColor = 'rgba(34, 197, 94, 0.1)';
                boxShadow = '0 0 15px rgba(34, 197, 94, 0.6)';
            } else {
                // Unauthorized - always critical since they're within critical distance
                borderColor = '#dc2626'; // Red
                bgColor = 'rgba(220, 38, 38, 0.15)';
                boxShadow = '0 0 20px rgba(220, 38, 38, 0.8)';
            }

            box.style.position = 'absolute';
            box.style.border = `4px solid ${borderColor}`;
            box.style.backgroundColor = bgColor;
            box.style.borderRadius = '12px';
            box.style.pointerEvents = 'none';
            box.style.transition = 'all 0.2s ease-out';
            box.style.boxShadow = boxShadow;

            const [top, right, bottom, left] = face.location;

            const width = right - left;
            const height = bottom - top;
            const expandX = width * 0.2;
            const expandY = height * 0.2;

            const expandedLeft = Math.max(0, left - expandX);
            const expandedTop = Math.max(0, top - expandY);
            const expandedRight = Math.min(video.videoWidth, right + expandX);
            const expandedBottom = Math.min(video.videoHeight, bottom + expandY);

            const boxLeft = (expandedLeft * scaleX) + offsetX;
            const boxTop = (expandedTop * scaleY) + offsetY;
            const boxWidth = (expandedRight - expandedLeft) * scaleX;
            const boxHeight = (expandedBottom - expandedTop) * scaleY;

            box.style.left = boxLeft + 'px';
            box.style.top = boxTop + 'px';
            box.style.width = boxWidth + 'px';
            box.style.height = boxHeight + 'px';

            // Create label
            const label = document.createElement('div');
            label.style.position = 'absolute';
            label.style.top = '-35px';
            label.style.left = '0';
            label.style.backgroundColor = borderColor;
            label.style.color = 'white';
            label.style.padding = '6px 12px';
            label.style.fontSize = '14px';
            label.style.borderRadius = '6px';
            label.style.fontWeight = 'bold';
            label.style.whiteSpace = 'nowrap';
            label.style.boxShadow = '0 2px 4px rgba(0,0,0,0.3)';

            const icon = document.createElement('i');
            if (face.is_authorized) {
                icon.className = 'fas fa-check-circle';
            } else {
                icon.className = 'fas fa-exclamation-triangle';
            }
            icon.style.marginRight = '6px';
            label.appendChild(icon);

            const nameText = document.createTextNode(face.display_name || face.name);
            label.appendChild(nameText);

            // Distance badge
            const distanceBadge = document.createElement('div');
            distanceBadge.style.position = 'absolute';
            distanceBadge.style.bottom = '-30px';
            distanceBadge.style.left = '0';
            distanceBadge.style.backgroundColor = 'rgba(220, 38, 38, 0.9)'; // Red for critical
            distanceBadge.style.color = 'white';
            distanceBadge.style.padding = '4px 10px';
            distanceBadge.style.fontSize = '12px';
            distanceBadge.style.borderRadius = '4px';
            distanceBadge.style.fontWeight = 'bold';
            distanceBadge.style.whiteSpace = 'nowrap';
            distanceBadge.style.boxShadow = '0 2px 4px rgba(0,0,0,0.3)';

            distanceBadge.innerHTML = `
            <i class="fas fa-ruler"></i> 
            ${face.distance_meters}m - CRITICAL DISTANCE
        `;

            box.appendChild(label);
            box.appendChild(distanceBadge);
            overlay.appendChild(box);
        });

        fpsCounter++;
    }

    // Toggle motion-gated recognition
    function toggleMotionGatedRecognition() {
        motionGatedRecognition = !motionGatedRecognition;

        const button = document.getElementById('toggleMotionGatedBtn');
        if (motionGatedRecognition) {
            button.innerHTML = '<i class="fas fa-shield-alt mr-1"></i>Motion-Gated: ON';
            button.className = 'bg-green-600 hover:bg-green-700 text-white px-3 py-2 rounded text-sm';
        } else {
            button.innerHTML = '<i class="fas fa-shield-alt mr-1"></i>Motion-Gated: OFF';
            button.className = 'bg-gray-600 hover:bg-gray-700 text-white px-3 py-2 rounded text-sm';
        }

        console.log('Motion-gated recognition:', motionGatedRecognition ? 'ENABLED' : 'DISABLED');
    }


    // Add distance settings panel toggle
    function toggleDistanceSettings() {
        const panel = document.getElementById('distanceSettingsPanel');
        panel.classList.toggle('hidden');
    }

    // Save distance settings
    // Save distance settings - UPDATED VERSION
    function saveDistanceSettings() {
        const maxDistance = document.getElementById('maxDistance').value;

        const formData = new FormData();
        formData.append('max_distance', maxDistance);

        fetch('/api/update_distance_settings', {
            method: 'POST',
            body: formData
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('Distance settings updated successfully!');
                } else {
                    alert('Failed to update settings: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Error updating distance settings:', error);
                alert('Error updating distance settings');
            });
    }



    // Load distance settings on page load - UPDATED VERSION
    function loadDistanceSettings() {
        fetch('/api/get_distance_settings')
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    document.getElementById('maxDistance').value = data.settings.max_detection_distance;
                    // Removed warning and critical distance loading
                }
            })
            .catch(error => console.error('Error loading distance settings:', error));
    }

    // Load distance settings on page load
    function loadDistanceSettings() {
        fetch('/api/get_distance_settings')
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    document.getElementById('maxDistance').value = data.settings.max_detection_distance;
                }
            })
            .catch(error => console.error('Error loading distance settings:', error));
    }

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', function () {
        loadRecentDetections();
        loadDistanceSettings();
    });

    function initializeOverlay() {
        const video = document.getElementById('videoElement');
        const overlay = document.getElementById('faceOverlay');

        // Make sure overlay matches video dimensions exactly
        const resizeOverlay = () => {
            const videoRect = video.getBoundingClientRect();
            overlay.style.width = videoRect.width + 'px';
            overlay.style.height = videoRect.height + 'px';
        };

        // Resize on video metadata load and window resize
        video.addEventListener('loadedmetadata', resizeOverlay);
        window.addEventListener('resize', resizeOverlay);

        // Initial resize
        resizeOverlay();
    }

    function takeScreenshot() {
        if (!cameraStream) {
            alert('Please start camera first');
            return;
        }

        const video = document.getElementById('videoElement');
        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0);

        canvas.toBlob(function (blob) {
            const formData = new FormData();
            formData.append('screenshot', blob, 'camera_capture_' + Date.now() + '.jpg');

            fetch('/api/save_screenshot', {
                method: 'POST',
                body: formData
            }).then(response => response.json())
                .then(data => {
                    if (data.success) {
                        alert('Screenshot saved successfully!');
                        loadRecentDetections();
                    } else {
                        alert('Failed to save screenshot: ' + (data.error || 'Unknown error'));
                    }
                });
        }, 'image/jpeg');
    }

    function toggleRecording() {
        if (!cameraStream) {
            alert('Please start camera first');
            return;
        }

        const button = document.getElementById('toggleRecording');

        if (!isRecording) {
            fetch('/api/start_recording', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        isRecording = true;
                        button.innerHTML = '<i class="fas fa-stop mr-1"></i>Stop Recording';
                        button.className = 'bg-red-600 hover:bg-red-700 text-white px-3 py-2 rounded text-sm';
                        updateRecordingStatus('Recording');
                    } else {
                        alert('Failed to start recording: ' + (data.error || 'Unknown error'));
                    }
                });
        } else {
            fetch('/api/stop_recording', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        isRecording = false;
                        button.innerHTML = '<i class="fas fa-record-vinyl mr-1"></i>Record';
                        button.className = 'bg-purple-600 hover:bg-purple-700 text-white px-3 py-2 rounded text-sm';
                        updateRecordingStatus('Stopped');
                    } else {
                        alert('Failed to stop recording: ' + (data.error || 'Unknown error'));
                    }
                });
        }
    }

    function toggleMotionDetection() {
        const action = motionDetectionActive ? 'stop_motion_detection' : 'start_motion_detection';

        fetch('/api/dashboard_action', {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: `action=${action}`
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    motionDetectionActive = !motionDetectionActive;
                    updateMotionDetectionStatus(motionDetectionActive ? 'Active' : 'Inactive');
                }
            });
    }

    function toggleFaceRecognition() {
        faceRecognitionActive = !faceRecognitionActive;

        if (faceRecognitionActive && cameraStream) {
            startFaceRecognition();
        } else {
            stopFaceRecognition();
            document.getElementById('faceOverlay').innerHTML = '';
        }

        updateFaceRecognitionStatus(faceRecognitionActive ? 'Active' : 'Inactive');
    }

    function playQuickMessage(messageType) {
        fetch('/api/dashboard_action', {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: `action=play_message&message_type=${messageType}`
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log('Message played:', data.result);
                } else {
                    console.error('Failed to play message:', data.error);
                }
            })
            .catch(error => console.error('Error playing message:', error));
    }

    function updateCameraStatus(status) {
        const element = document.getElementById('cameraStatus');
        element.textContent = status;
        element.className = status === 'Active' ?
            'bg-green-100 text-green-800 px-2 py-1 rounded text-sm' :
            'bg-red-100 text-red-800 px-2 py-1 rounded text-sm';
    }

    function updateRecordingStatus(status) {
        const element = document.getElementById('recordingStatus');
        element.textContent = status;
        element.className = status === 'Recording' ?
            'bg-green-100 text-green-800 px-2 py-1 rounded text-sm' :
            'bg-red-100 text-red-800 px-2 py-1 rounded text-sm';
    }

    function updateMotionDetectionStatus(status) {
        const element = document.getElementById('motionDetectionStatus');
        element.textContent = status;
        element.className = status === 'Active' ?
            'bg-green-100 text-green-800 px-2 py-1 rounded text-sm' :
            'bg-yellow-100 text-yellow-800 px-2 py-1 rounded text-sm';
    }

    function updateFaceRecognitionStatus(status) {
        const element = document.getElementById('faceRecognitionStatus');
        element.textContent = status;
        element.className = status === 'Active' ?
            'bg-green-100 text-green-800 px-2 py-1 rounded text-sm' :
            'bg-red-100 text-red-800 px-2 py-1 rounded text-sm';
    }

    function loadRecentDetections() {
        // Use the unauthorized_detections endpoint instead of dashboard_feed
        fetch('/api/unauthorized_detections')
            .then(response => response.json())
            .then(data => {
                const tbody = document.getElementById('detectionsTable');

                if (!data.success) {
                    tbody.innerHTML = `
                <tr>
                    <td colspan="6" class="px-4 py-4 text-center text-red-500">
                        <i class="fas fa-exclamation-triangle mr-2"></i>
                        Error loading alerts
                    </td>
                </tr>
            `;
                    return;
                }

                if (!data.detections || data.detections.length === 0) {
                    tbody.innerHTML = `
                <tr>
                    <td colspan="6" class="px-4 py-8 text-center text-gray-500">
                        <i class="fas fa-shield-check text-3xl mb-2 text-green-400"></i>
                        <p class="text-lg font-semibold">All Clear!</p>
                        <p class="text-sm mt-1">No security alerts detected</p>
                    </td>
                </tr>
            `;
                    return;
                }

                tbody.innerHTML = '';

                data.detections.forEach(detection => {
                    const row = tbody.insertRow();
                    const timestamp = new Date(detection.timestamp).toLocaleString();
                    const isFaceDetection = detection.type === 'face_detection';
                    const typeClass = isFaceDetection ?
                        'bg-red-100 text-red-800' : 'bg-orange-100 text-orange-800';
                    const displayName = detection.person_name || 'Unknown';

                    // Better confidence display handling
                    let confidenceDisplay = 'N/A';
                    if (detection.confidence !== null && detection.confidence !== undefined) {
                        confidenceDisplay = (detection.confidence * 100).toFixed(1) + '%';
                    }

                    row.innerHTML = `
                <td class="px-4 py-2 text-sm">${timestamp}</td>
                <td class="px-4 py-2">
                    <span class="px-2 py-1 rounded text-sm ${typeClass}">
                        ${detection.type.replace('_', ' ')}
                    </span>
                </td>
                <td class="px-4 py-2 font-semibold ${isFaceDetection ? 'text-red-600' : 'text-orange-600'}">
                    ${displayName}
                </td>
                <td class="px-4 py-2">
                    <span class="px-2 py-1 bg-gray-100 rounded text-xs font-mono">
                        ${confidenceDisplay}
                    </span>
                </td>
                <td class="px-4 py-2">
                    <span class="px-2 py-1 rounded text-sm ${getAlertLevelClass(detection.alert_level)}">
                        Level ${detection.alert_level}
                    </span>
                </td>
                <td class="px-4 py-2">
                    ${detection.screenshot_path ?
                            `<a href="/${detection.screenshot_path}" target="_blank" class="text-blue-600 hover:underline">
                            <i class="fas fa-image mr-1"></i>View
                        </a>` : 'N/A'}
                </td>
            `;
                });
            })
            .catch(error => {
                console.error('Error loading alerts:', error);
                const tbody = document.getElementById('detectionsTable');
                tbody.innerHTML = `
            <tr>
                <td colspan="6" class="px-4 py-4 text-center text-red-500">
                    Network error loading alerts
                </td>
            </tr>
        `;
            });
    }

    // Make sure this function exists
    function getAlertLevelClass(level) {
        switch (level) {
            case 1: return 'bg-green-100 text-green-800 border border-green-200';
            case 2: return 'bg-yellow-100 text-yellow-800 border border-yellow-200';
            case 3: return 'bg-red-100 text-red-800 border border-red-200';
            default: return 'bg-gray-100 text-gray-800 border border-gray-200';
        }
    }

    document.addEventListener('DOMContentLoaded', function () {
        loadRecentDetections();
    });

    setInterval(loadRecentDetections, 10000);


    function toggleMotionDetection() {
        if (!cameraStream) {
            alert('Please start camera first');
            return;
        }

        const action = motionDetectionActive ? 'stop_motion_detection' : 'start_motion_detection';

        fetch('/api/dashboard_action', {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: `action=${action}`
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    motionDetectionActive = !motionDetectionActive;
                    updateMotionDetectionStatus(motionDetectionActive ? 'Active' : 'Inactive');

                    if (motionDetectionActive) {
                        startMotionDetection();
                    } else {
                        stopMotionDetection();
                    }
                }
            });
    }

    function startMotionDetection() {
        if (motionDetectionInterval) return;

        console.log('Starting motion detection');
        motionDetectionInterval = setInterval(() => {
            detectMotion();
        }, 1000); // Detect every second
    }

    function stopMotionDetection() {
        if (motionDetectionInterval) {
            clearInterval(motionDetectionInterval);
            motionDetectionInterval = null;
        }
    }

    // Make sure this function exists
    function getAlertLevelClass(level) {
        switch (level) {
            case 1: return 'bg-green-100 text-green-800 border border-green-200';
            case 2: return 'bg-yellow-100 text-yellow-800 border border-yellow-200';
            case 3: return 'bg-red-100 text-red-800 border border-red-200';
            default: return 'bg-gray-100 text-gray-800 border border-gray-200';
        }
    }

    document.addEventListener('DOMContentLoaded', function () {
        loadRecentDetections();
    });

    setInterval(loadRecentDetections, 10000);


    function toggleMotionDetection() {
        if (!cameraStream) {
            alert('Please start camera first');
            return;
        }

        const action = motionDetectionActive ? 'stop_motion_detection' : 'start_motion_detection';

        fetch('/api/dashboard_action', {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: `action = ${action} `
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    motionDetectionActive = !motionDetectionActive;
                    updateMotionDetectionStatus(motionDetectionActive ? 'Active' : 'Inactive');

                    if (motionDetectionActive) {
                        startMotionDetection();
                    } else {
                        stopMotionDetection();
                    }
                }
            });
    }

    function startMotionDetection() {
        if (motionDetectionInterval) return;

        console.log('Starting motion detection');
        motionDetectionInterval = setInterval(() => {
            detectMotion();
        }, 1000); // Detect every second
    }

    function stopMotionDetection() {
        if (motionDetectionInterval) {
            clearInterval(motionDetectionInterval);
            motionDetectionInterval = null;
            document.getElementById('motionOverlay').innerHTML = '';
            console.log('Motion detection stopped');
        }
    }

    function detectMotion() {
        const video = document.getElementById('videoElement');
        if (!video.srcObject || video.readyState !== video.HAVE_ENOUGH_DATA) return;

        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0);

        const imageData = canvas.toDataURL('image/jpeg');

        const formData = new FormData();
        formData.append('image_data', imageData);

        fetch('/api/detect_motion', {
            method: 'POST',
            body: formData
        })
            .then(response => response.json())
            .then(data => {
                if (data.success && data.motion_detected) {
                    // Update human motiofn status if available
                    if (data.human_detected !== undefined) {
                        updateHumanMotionStatus(data.human_detected);
                    }
                } else {
                    document.getElementById('motionOverlay').innerHTML = '';
                }
            })
            .catch(error => console.error('Motion detection error:', error));
    }

    // Helper function to update human motion status
    function updateHumanMotionStatus(humanDetected) {
        if (humanDetected) {
            console.log('Human motion detected - enabling face detection');
            // You can add visual indicators here if needed
        }
    }

    function displayMotionDetections(detections) {
        const overlay = document.getElementById('motionOverlay');
        const video = document.getElementById('videoElement');

        overlay.innerHTML = '';

        detections.forEach(detection => {
            // ONLY display animal detections, NOT human detections
            if (detection.type === 'animal') {
                const box = document.createElement('div');
                box.style.position = 'absolute';
                box.style.border = '3px solid #D97706'; // Amber for animals
                box.style.backgroundColor = 'rgba(217, 119, 6, 0.15)';
                box.style.borderRadius = '8px';
                box.style.pointerEvents = 'none';
                box.style.transition = 'all 0.3s ease-out';
                box.style.boxShadow = '0 0 10px rgba(217, 119, 6, 0.5)';

                const videoRect = video.getBoundingClientRect();
                const scaleX = videoRect.width / video.videoWidth;
                const scaleY = videoRect.height / video.videoHeight;

                const [x, y, w, h] = detection.bbox;
                box.style.left = (x * scaleX) + 'px';
                box.style.top = (y * scaleY) + 'px';
                box.style.width = (w * scaleX) + 'px';
                box.style.height = (h * scaleY) + 'px';

                const label = document.createElement('div');
                label.style.position = 'absolute';
                label.style.top = '-35px';
                label.style.left = '0';
                label.style.backgroundColor = '#D97706';
                label.style.color = 'white';
                label.style.padding = '4px 8px';
                label.style.fontSize = '12px';
                label.style.borderRadius = '4px';
                label.style.fontWeight = 'bold';
                label.style.pointerEvents = 'none';
                label.style.whiteSpace = 'nowrap';
                label.style.boxShadow = '0 2px 4px rgba(0,0,0,0.2)';
                label.innerHTML = `
                        <i i class="fas fa-paw mr-1" ></i >
                            ANIMAL(${(detection.confidence * 100).toFixed(0)}%)
                    `;

                box.appendChild(label);
                overlay.appendChild(box);
            }
            // Human detections are NOT displayed with boxes
        });
    }


    function updateMotionDetectionStatus(status) {
        const element = document.getElementById('motionDetectionStatus');
        element.textContent = status;
        element.className = status === 'Active' ?
            'bg-green-100 text-green-800 px-2 py-1 rounded text-sm' :
            'bg-yellow-100 text-yellow-800 px-2 py-1 rounded text-sm';

        // Update the toggle button
        const button = document.getElementById('toggleMotionDetection');
        if (status === 'Active') {
            button.innerHTML = '<i class="fas fa-stop mr-1"></i>Stop Motion';
            button.className = 'bg-red-600 hover:bg-red-700 text-white px-3 py-2 rounded text-sm';
        } else {
            button.innerHTML = '<i class="fas fa-running mr-1"></i>Motion Detection';
            button.className = 'bg-yellow-600 hover:bg-yellow-700 text-white px-3 py-2 rounded text-sm';
        }
    }

    function updateDebugPanel(motionStatus) {
        if (!motionStatus) return;

        document.getElementById('debugHumanMotion').textContent = motionStatus.human_motion_detected ? 'YES' : 'NO';
        document.getElementById('debugHumanMotion').className = motionStatus.human_motion_detected ?
            'font-bold text-green-600' : 'font-bold text-red-600';

        document.getElementById('debugFaceDetection').textContent = motionStatus.face_detection_enabled ? 'YES' : 'NO';
        document.getElementById('debugFaceDetection').className = motionStatus.face_detection_enabled ?
            'font-bold text-green-600' : 'font-bold text-red-600';

        // Update step 3 status
        const step3 = document.getElementById('faceDetectionStep');
        if (motionStatus.face_detection_enabled) {
            step3.innerHTML = `
                    <div div class="w-6 h-6 rounded-full bg-green-500 flex items-center justify-center text-white text-xs font-bold" > 3</div >
                        <span class="text-green-600"><strong>Face Detection:</strong> ACTIVE - Human detected within critical distance</span>
                `;
        } else {
            step3.innerHTML = `
                    <div div class="w-6 h-6 rounded-full bg-gray-400 flex items-center justify-center text-white text-xs font-bold" > 3</div >
                        <span class="text-gray-600"><strong>Face Detection:</strong> INACTIVE - Waiting for human motion within 1.5m</span>
        `;
        }
    }

    function clearUnauthorizedCache() {
        fetch('/api/clear_unauthorized_cache', { method: 'POST' })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert(data.message);
                    document.getElementById('debugCachedFaces').textContent = '0';
                }
            });
    }


</script>
{% endblock %}
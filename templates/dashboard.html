{% extends "base.html" %}

{% block title %}Dashboard - Security System{% endblock %}

{% block content %}
<div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
    <!-- Live Camera Feed with Face Recognition -->
    <div class="lg:col-span-2">
        <div class="bg-white rounded-lg shadow-lg p-6">
            <h2 class="text-2xl font-bold mb-4 flex items-center">
                <i class="fas fa-camera mr-3 text-blue-600"></i>
                Live Camera Feed
            </h2>
            <div class="relative">
                <video id="videoElement" class="w-full h-64 bg-black rounded-lg" autoplay muted></video>
                <canvas id="overlayCanvas" class="absolute top-0 left-0 w-full h-64 pointer-events-none"></canvas>
                <div class="absolute top-2 right-2 bg-red-600 text-white px-2 py-1 rounded text-sm">
                    <i class="fas fa-circle mr-1"></i>LIVE
                </div>
                <!-- Enhanced face detection overlay with better fitting boxes -->
                <div id="faceOverlay" class="absolute top-0 left-0 w-full h-full pointer-events-none"></div>
            </div>

            <!-- Camera Controls -->
            <div class="mt-4 bg-gray-50 rounded-lg p-4">
                <h4 class="font-semibold mb-3">Camera Controls</h4>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-2">
                    <button id="startCamera"
                        class="bg-green-600 hover:bg-green-700 text-white px-3 py-2 rounded text-sm">
                        <i class="fas fa-camera mr-1"></i>Start Camera
                    </button>
                    <button id="stopCamera" class="bg-red-600 hover:bg-red-700 text-white px-3 py-2 rounded text-sm">
                        <i class="fas fa-stop mr-1"></i>Stop Camera
                    </button>
                    <button id="takeScreenshot"
                        class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-2 rounded text-sm">
                        <i class="fas fa-camera mr-1"></i>Screenshot
                    </button>
                </div>
                <div class="mt-3 text-sm text-gray-600">
                    <i class="fas fa-info-circle mr-1"></i>
                    Camera starts automatically when page loads
                </div>
            </div>

            <!-- Enhanced controls with quick actions -->
            <div class="mt-4 grid grid-cols-2 md:grid-cols-4 gap-2">
                <button id="toggleRecording" class="bg-red-600 hover:bg-red-700 text-white px-3 py-2 rounded text-sm">
                    <i class="fas fa-stop mr-1"></i>Stop Recording
                </button>
                <button id="toggleMotionDetection"
                    class="bg-red-600 hover:bg-red-700 text-white px-3 py-2 rounded text-sm">
                    <i class="fas fa-stop mr-1"></i>Stop Motion
                </button>
                <button id="toggleFaceRecognition"
                    class="bg-red-600 hover:bg-red-700 text-white px-3 py-2 rounded text-sm">
                    <i class="fas fa-stop mr-1"></i>Stop Face Recognition
                </button>
                <button onclick="playQuickMessage('warning')"
                    class="bg-orange-600 hover:bg-orange-700 text-white px-3 py-2 rounded text-sm">
                    <i class="fas fa-volume-up mr-1"></i>Warning
                </button>
            </div>
            <!-- Motion Detection Overlay -->
            <div id="motionOverlay" class="absolute top-0 left-0 w-full h-full pointer-events-none"></div>
        </div>
    </div>

    <!-- System Status -->
    <div class="bg-white rounded-lg shadow-lg p-6">
        <h3 class="text-lg font-bold mb-4 flex items-center">
            <i class="fas fa-heartbeat mr-2 text-green-600"></i>
            System Status
        </h3>
        <div class="space-y-3">
            <div class="flex justify-between items-center">
                <span>Camera Feed</span>
                <span id="cameraStatus" class="bg-green-100 text-green-800 px-2 py-1 rounded text-sm">Active</span>
            </div>
            <div class="flex justify-between items-center">
                <span>Face Recognition</span>
                <span id="faceRecognitionStatus"
                    class="bg-green-100 text-green-800 px-2 py-1 rounded text-sm">Active</span>
            </div>
            <div class="flex justify-between items-center">
                <span>Motion Detection</span>
                <span id="motionDetectionStatus"
                    class="bg-green-100 text-green-800 px-2 py-1 rounded text-sm">Active</span>
            </div>
            <div class="flex justify-between items-center">
                <span>Recording</span>
                <span id="recordingStatus"
                    class="bg-green-100 text-green-800 px-2 py-1 rounded text-sm">Recording</span>
            </div>
        </div>
        <!-- Twilio Alert Control (Replaces Today's Stats) -->
        <div class="bg-white rounded-lg shadow-lg p-6">
            <h3 class="text-lg font-bold mb-4 flex items-center">
                <i class="fas fa-phone-alt mr-2 text-blue-600"></i>
                Alert Controls
            </h3>
            <div class="space-y-4">
                <!-- Twilio Toggle -->
                <div class="flex justify-between items-center">
                    <div>
                        <span class="font-semibold">Twilio Phone Alerts</span>
                        <p class="text-sm text-gray-600">Enable/disable automatic phone calls</p>
                    </div>
                    <div class="flex items-center space-x-3">
                        <span id="twilioStatusText" class="text-sm font-medium px-2 py-1 rounded 
                    bg-green-100 text-green-800">ENABLED</span>
                        <button id="twilioToggle"
                            class="relative inline-flex h-6 w-11 items-center rounded-full bg-green-600 transition-colors duration-200 ease-in-out">
                            <span
                                class="inline-block h-4 w-4 transform rounded-full bg-white transition-transform duration-200 ease-in-out translate-x-6"></span>
                        </button>
                    </div>
                </div>

                <!-- Status Indicator -->
                <div class="bg-gray-50 rounded-lg p-3">
                    <div class="flex items-center text-sm">
                        <i class="fas fa-info-circle mr-2 text-blue-500"></i>
                        <span id="twilioCurrentStatus" class="font-semibold text-green-600">
                            üìû Phone calls will be made for security alerts
                        </span>
                    </div>
                </div>

                <!-- Quick Actions -->
                <div class="grid grid-cols-2 gap-2 mt-2">
                    <button onclick="viewAlertSettings()"
                        class="bg-gray-600 hover:bg-gray-700 text-white px-3 py-2 rounded text-sm">
                        <i class="fas fa-cog mr-1"></i>Settings
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Recent Unauthorized Detections -->
<div class="mt-6 bg-white rounded-lg shadow-lg p-6">
    <h3 class="text-lg font-bold mb-4 flex items-center">
        <i class="fas fa-list-alt mr-2 text-blue-600"></i>
        Recent Security Logs (All Activities)
    </h3>
    <div class="overflow-x-auto">
        <table class="min-w-full table-auto">
            <thead>
                <tr class="bg-gray-50">
                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Time</th>
                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Type</th>
                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Detection
                    </th>
                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                        Confidence</th>
                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Actions
                    </th>
                </tr>
            </thead>
            <tbody id="detectionsTable">
                <!-- Detections will be loaded here -->
                <tr>
                    <td colspan="6" class="px-4 py-8 text-center text-gray-500">
                        <i class="fas fa-shield-check text-3xl mb-2 text-green-400"></i>
                        <p class="text-lg font-semibold">Loading security alerts...</p>
                    </td>
                </tr>
            </tbody>
        </table>
    </div>
</div>


<!-- Distance Settings Panel -->
<div class="mt-6 bg-white rounded-lg shadow-lg p-6">
    <div class="flex justify-between items-center mb-4">
        <h3 class="text-lg font-bold flex items-center">
            <i class="fas fa-ruler-combined mr-2 text-purple-600"></i>
            Distance Detection Settings
        </h3>
        <button onclick="toggleDistanceSettings()"
            class="bg-purple-600 hover:bg-purple-700 text-white px-3 py-1 rounded text-sm">
            <i class="fas fa-cog mr-1"></i>Configure
        </button>
    </div>

    <!-- Collapsible Settings Panel -->
    <div id="distanceSettingsPanel" class="hidden">
        <div class="bg-gray-50 rounded-lg p-4 space-y-4">
            <!-- Distance Thresholds -->
            <div>
                <label class="block text-sm font-semibold mb-2">
                    <i class="fas fa-expand-arrows-alt mr-1"></i>
                    Maximum Detection Distance (meters)
                </label>
                <input type="number" id="maxDistance" value="6.0" step="0.5" min="1" max="20"
                    class="w-full border rounded px-3 py-2">
                <p class="text-xs text-gray-600 mt-1">
                    Maximum distance at which faces will be detected and analyzed
                </p>
            </div>

            <!-- Save Button -->
            <button onclick="saveDistanceSettings()"
                class="w-full bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded font-semibold">
                <i class="fas fa-save mr-2"></i>Save Settings
            </button>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    // Face recognition state management - ALL SET TO TRUE BY DEFAULT
    let cameraStream = null;
    let isRecording = true; // Recording on by default
    let faceRecognitionActive = true; // Face recognition on by default
    let motionDetectionActive = true; // Motion detection on by default
    let recognitionInterval = null;
    let detectionIntervalMs = 1000;
    let fpsCounter = 0;
    let lastFpsUpdate = Date.now();
    let motionDetectionInterval = null;

    // Motion-gated face recognition state
    let motionGatedRecognition = true;
    let lastMotionDetectionTime = null;
    let motionTimeout = 5000;

    // Face recognition queue system
    let isProcessingFaceRecognition = false;
    let faceRecognitionQueue = [];
    let pendingFaceRecognition = null;

    let twilioAlertsEnabled = true; // Default to enabled


    // Camera controls
    document.getElementById('startCamera').addEventListener('click', startCamera);
    document.getElementById('stopCamera').addEventListener('click', stopCamera);
    document.getElementById('takeScreenshot').addEventListener('click', takeScreenshot);
    document.getElementById('toggleRecording').addEventListener('click', toggleRecording);
    document.getElementById('toggleMotionDetection').addEventListener('click', toggleMotionDetection);
    document.getElementById('toggleFaceRecognition').addEventListener('click', toggleFaceRecognition);

    // AUTO-START EVERYTHING WHEN PAGE LOADS
    document.addEventListener('DOMContentLoaded', function () {
        console.log('üöÄ Auto-starting all security systems...');

        // Start camera immediately
        startCamera();

        // Start recording automatically
        startAutoRecording();

        // Start motion detection automatically
        startMotionDetection();

        // Load other components
        loadRecentDetections();
        loadDistanceSettings();
        refreshFaceTracking();

        // Load saved Twilio state from localStorage
        loadTwilioState();

        // Initialize Twilio toggle
        initializeTwilioToggle();

        // Update UI to show everything is active
        updateRecordingStatus('Recording');
        updateMotionDetectionStatus('Active');
        updateFaceRecognitionStatus('Active');

        // Set up auto-refresh intervals
        setInterval(loadRecentDetections, 10000);
        setInterval(refreshFaceTracking, 30000);
    });

    async function startCamera() {
        try {
            cameraStream = await navigator.mediaDevices.getUserMedia({
                video: {
                    width: { ideal: 1280 },
                    height: { ideal: 720 },
                    facingMode: 'user'
                },
                audio: false
            });

            const videoElement = document.getElementById('videoElement');
            videoElement.srcObject = cameraStream;

            // Wait for video to be ready
            await new Promise((resolve) => {
                videoElement.onloadedmetadata = () => {
                    videoElement.play();
                    resolve();
                };
            });

            // Initialize overlays and indicators
            initializeOverlay();
            initializeMotionIndicator();
            updateCameraStatus('Active');

            cameraStream.getTracks().forEach(track => {
                track.onended = () => {
                    stopCamera();
                };
            });

            if (faceRecognitionActive) {
                startFaceRecognition();
            }

            console.log('‚úÖ Camera started successfully');

        } catch (error) {
            console.error('Error accessing camera:', error);
            if (error.name === 'NotAllowedError') {
                alert('Camera permission denied. Please allow camera access to continue.');
            } else if (error.name === 'NotFoundError') {
                alert('No camera found. Please check if your camera is connected and try again.');
            } else {
                alert('Could not start camera: ' + error.message);
            }
        }
    }

    // Load Twilio state from localStorage
    function loadTwilioState() {
        const savedState = localStorage.getItem('twilioAlertsEnabled');
        if (savedState !== null) {
            twilioAlertsEnabled = savedState === 'true';
            console.log(`üì± Loaded Twilio state: ${twilioAlertsEnabled ? 'ENABLED' : 'DISABLED'}`);
        } else {
            // Default to enabled if no saved state
            twilioAlertsEnabled = true;
            localStorage.setItem('twilioAlertsEnabled', 'true');
            console.log('üì± No saved Twilio state, defaulting to ENABLED');
        }
    }

    // Save Twilio state to localStorage
    function saveTwilioState(enabled) {
        localStorage.setItem('twilioAlertsEnabled', enabled.toString());
        console.log(`üì± Saved Twilio state: ${enabled ? 'ENABLED' : 'DISABLED'}`);
    }

    // Working Twilio toggle functionality with persistence
    function initializeTwilioToggle() {
        const toggle = document.getElementById('twilioToggle');
        const statusText = document.getElementById('twilioStatusText');
        const currentStatus = document.getElementById('twilioCurrentStatus');

        // Initialize the toggle based on saved state
        updateToggleAppearance();
        updateTwilioUI();

        // Add click event to the button
        toggle.addEventListener('click', function () {
            twilioAlertsEnabled = !twilioAlertsEnabled;

            // Save state to localStorage
            saveTwilioState(twilioAlertsEnabled);

            // Update button appearance
            updateToggleAppearance();
            updateTwilioUI();

            // Show confirmation
            if (twilioAlertsEnabled) {
                showNotification('üìû Twilio alerts ENABLED - Phone calls will be made for security alerts', 'success');
            } else {
                showNotification('üîï Twilio alerts DISABLED - Phone calls will be blocked', 'warning');
            }

            // Log the state change
            console.log(`Twilio alerts ${twilioAlertsEnabled ? 'ENABLED' : 'DISABLED'}`);
        });

        function updateToggleAppearance() {
            if (twilioAlertsEnabled) {
                toggle.classList.remove('bg-gray-400');
                toggle.classList.add('bg-green-600');
                toggle.querySelector('span').classList.remove('translate-x-1');
                toggle.querySelector('span').classList.add('translate-x-6');
            } else {
                toggle.classList.remove('bg-green-600');
                toggle.classList.add('bg-gray-400');
                toggle.querySelector('span').classList.remove('translate-x-6');
                toggle.querySelector('span').classList.add('translate-x-1');
            }
        }

        function updateTwilioUI() {
            if (twilioAlertsEnabled) {
                statusText.textContent = 'ENABLED';
                statusText.className = 'text-sm font-medium px-2 py-1 rounded bg-green-100 text-green-800';
                currentStatus.textContent = 'üìû Phone calls will be made for security alerts';
                currentStatus.className = 'font-semibold text-green-600';
            } else {
                statusText.textContent = 'DISABLED';
                statusText.className = 'text-sm font-medium px-2 py-1 rounded bg-red-100 text-red-800';
                currentStatus.textContent = 'üîï Phone calls are BLOCKED - alerts will be logged only';
                currentStatus.className = 'font-semibold text-red-600';
            }
        }
    }

    // Modified recognizeFaces function with Twilio blocking
    function recognizeFaces() {
        return new Promise((resolve, reject) => {
            const video = document.getElementById('videoElement');
            if (!video.srcObject || video.readyState !== video.HAVE_ENOUGH_DATA) {
                reject(new Error('Video not ready'));
                return;
            }

            try {
                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0);

                const imageData = canvas.toDataURL('image/jpeg', 0.8);

                const endpoint = motionGatedRecognition ? '/api/recognize_faces_with_motion' : '/api/recognize_faces';

                const formData = new FormData();
                formData.append('image_data', imageData);

                // Include Twilio state in the request
                formData.append('twilio_enabled', twilioAlertsEnabled.toString());

                fetch(endpoint, {
                    method: 'POST',
                    body: formData
                })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data.success) {
                            displayFaceBoxes(data.faces || []);
                            if (data.motion_status) {
                                updateMotionStatusIndicator(data.motion_status);
                            }

                            // Show Twilio status in console for debugging
                            if (!twilioAlertsEnabled) {
                                console.log('üîï Twilio alerts are disabled - calls blocked');
                            }
                        } else {
                            console.error('Face recognition failed:', data.error);
                        }
                        resolve(data);
                    })
                    .catch(error => {
                        console.error('Face recognition fetch error:', error);
                        reject(error);
                    });
            } catch (error) {
                console.error('Error in recognizeFaces:', error);
                reject(error);
            }
        });
    }

    // Test call function
    function testTwilioCall() {
        if (!twilioAlertsEnabled) {
            showNotification('‚ùå Twilio alerts are currently disabled. Enable them first to test calls.', 'error');
            return;
        }

        const testNumber = prompt('Enter a phone number to test Twilio call (include country code, e.g., +1234567890):');

        if (!testNumber) return;

        showNotification('üìû Making test call...', 'info');

        fetch('/api/test_twilio_call', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: `test_number=${encodeURIComponent(testNumber)}`
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showNotification('‚úÖ Test call initiated successfully!', 'success');
                } else {
                    showNotification('‚ùå Test call failed: ' + (data.error || 'Unknown error'), 'error');
                }
            })
            .catch(error => {
                console.error('Test call error:', error);
                showNotification('‚ùå Test call failed: Network error', 'error');
            });
    }

    // View alert settings function
    function viewAlertSettings() {
        window.location.href = '/twilio_alerts';
    }

    // Add function to manually reset Twilio state (for debugging)
    function resetTwilioState() {
        if (confirm('Reset Twilio state to default (ENABLED)?')) {
            localStorage.removeItem('twilioAlertsEnabled');
            twilioAlertsEnabled = true;
            initializeTwilioToggle();
            showNotification('üîÑ Twilio state reset to ENABLED', 'info');
        }
    }

    // Add this utility function if you don't have it
    function showNotification(message, type = 'info') {
        // Remove any existing notifications
        const existingNotifications = document.querySelectorAll('[data-notification]');
        existingNotifications.forEach(notification => notification.remove());

        // Create notification element
        const notification = document.createElement('div');
        notification.setAttribute('data-notification', 'true');
        notification.className = `fixed top-4 right-4 z-50 p-4 rounded-lg shadow-lg text-white max-w-sm transform transition-all duration-300 ${type === 'success' ? 'bg-green-600' :
            type === 'warning' ? 'bg-orange-600' :
                type === 'error' ? 'bg-red-600' : 'bg-blue-600'
            }`;

        notification.innerHTML = `
        <div class="flex items-center justify-between">
            <div class="flex items-center">
                <i class="fas fa-${type === 'success' ? 'check-circle' : type === 'warning' ? 'exclamation-triangle' : type === 'error' ? 'times-circle' : 'info-circle'} mr-2"></i>
                <span>${message}</span>
            </div>
            <button onclick="this.parentElement.parentElement.remove()" class="ml-4 text-white hover:text-gray-200">
                <i class="fas fa-times"></i>
            </button>
        </div>
    `;

        document.body.appendChild(notification);

        // Auto-remove after 5 seconds
        setTimeout(() => {
            if (notification.parentElement) {
                notification.style.opacity = '0';
                notification.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    if (notification.parentElement) {
                        document.body.removeChild(notification);
                    }
                }, 300);
            }
        }, 5000);
    }

    function startAutoRecording() {
        if (!cameraStream) {
            console.log('Waiting for camera to start recording...');
            setTimeout(startAutoRecording, 1000);
            return;
        }

        fetch('/api/start_recording', { method: 'POST' })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    isRecording = true;
                    updateRecordingStatus('Recording');
                    console.log('‚úÖ Auto-recording started');
                } else {
                    console.error('Failed to start auto-recording:', data.error);
                }
            })
            .catch(error => {
                console.error('Error starting auto-recording:', error);
            });
    }

    function stopCamera() {
        if (cameraStream) {
            cameraStream.getTracks().forEach(track => track.stop());
            document.getElementById('videoElement').srcObject = null;
            cameraStream = null;

            stopFaceRecognition();
            stopMotionDetection();
            document.getElementById('faceOverlay').innerHTML = '';
            updateCameraStatus('Inactive');
        }
    }

    function stopFaceRecognition() {
        if (recognitionInterval) {
            clearInterval(recognitionInterval);
            recognitionInterval = null;
        }

        // Clear any pending requests
        faceRecognitionQueue = [];
        isProcessingFaceRecognition = false;
        pendingFaceRecognition = null;
    }

    function startFaceRecognition() {
        if (recognitionInterval) return;

        console.log('‚úÖ Starting face recognition');

        recognitionInterval = setInterval(() => {
            queueFaceRecognition();
        }, detectionIntervalMs);
    }

    // Queue-based face recognition
    function queueFaceRecognition() {
        const video = document.getElementById('videoElement');
        if (!video.srcObject || video.readyState !== video.HAVE_ENOUGH_DATA) {
            return;
        }

        if (isProcessingFaceRecognition) {
            return;
        }

        processFaceRecognition();
    }

    // Process face recognition one at a time
    async function processFaceRecognition() {
        if (isProcessingFaceRecognition) {
            return;
        }

        const video = document.getElementById('videoElement');
        if (!video.srcObject || video.readyState !== video.HAVE_ENOUGH_DATA) {
            return;
        }

        isProcessingFaceRecognition = true;

        try {
            await recognizeFaces();
        } catch (error) {
            console.error('Face recognition error:', error);
            setTimeout(() => {
                if (cameraStream) {
                    console.log('Attempting to restart face recognition...');
                    isProcessingFaceRecognition = false;
                }
            }, 5000);
        } finally {
            setTimeout(() => {
                isProcessingFaceRecognition = false;
            }, 200);
        }
    }

    function updateMotionStatusIndicator(status) {
        let indicator = document.getElementById('motionStatusIndicator');

        if (!indicator) {
            return;
        }

        let statusHTML = '';

        if (status.human_motion_detected) {
            statusHTML = `
            <i class="fas fa-running text-green-400 mr-1"></i>
            <span class="text-green-400">Motion Detected</span>
        `;
        } else {
            statusHTML = `
            <i class="fas fa-ban text-red-400 mr-1"></i>
            <span class="text-red-400">No Motion</span>
        `;
        }

        if (status.face_detection_enabled) {
            statusHTML += `
            <div class="text-xs text-green-400 mt-1">
                <i class="fas fa-user-check mr-1"></i>
                <strong>Face Detection:</strong> ACTIVE
            </div>
        `;
        } else {
            statusHTML += `
            <div class="text-xs text-gray-300 mt-1">
                <i class="fas fa-user-slash mr-1"></i>
                <strong>Face Detection:</strong> INACTIVE
            </div>
        `;
        }

        indicator.innerHTML = statusHTML;
    }

    function initializeMotionIndicator() {
        const videoContainer = document.getElementById('videoElement').parentNode;
        let indicator = document.getElementById('motionStatusIndicator');

        if (!indicator) {
            indicator = document.createElement('div');
            indicator.id = 'motionStatusIndicator';
            indicator.className = 'absolute top-2 left-2 bg-black bg-opacity-70 text-white px-3 py-2 rounded text-sm z-10';
            videoContainer.appendChild(indicator);
        }
    }

    function displayFaceBoxes(faces) {
        const overlay = document.getElementById('faceOverlay');
        const video = document.getElementById('videoElement');

        overlay.innerHTML = '';

        const videoRect = video.getBoundingClientRect();
        const videoAspectRatio = video.videoWidth / video.videoHeight;
        const displayAspectRatio = videoRect.width / videoRect.height;

        let scaleX, scaleY, offsetX = 0, offsetY = 0;

        if (displayAspectRatio > videoAspectRatio) {
            scaleY = videoRect.height / video.videoHeight;
            scaleX = scaleY;
            offsetX = (videoRect.width - (video.videoWidth * scaleX)) / 2;
        } else {
            scaleX = videoRect.width / video.videoWidth;
            scaleY = scaleX;
            offsetY = (videoRect.height - (video.videoHeight * scaleY)) / 2;
        }

        faces.forEach(face => {
            if (!face.within_detection_range && !face.is_authorized) {
                return;
            }

            const box = document.createElement('div');

            let borderColor, bgColor, boxShadow;

            if (face.is_authorized) {
                // Green for authorized persons
                borderColor = '#22c55e';
                bgColor = 'rgba(34, 197, 94, 0.1)';
                boxShadow = '0 0 15px rgba(34, 197, 94, 0.6)';
            } else if (face.is_known_person) {
                // Yellow for known persons (non-threatening)
                borderColor = '#eab308';
                bgColor = 'rgba(234, 179, 8, 0.15)';
                boxShadow = '0 0 15px rgba(234, 179, 8, 0.6)';
            } else {
                // Red for unauthorized
                borderColor = '#dc2626';
                bgColor = 'rgba(220, 38, 38, 0.15)';
                boxShadow = '0 0 20px rgba(220, 38, 38, 0.8)';
            }

            box.style.position = 'absolute';
            box.style.border = `4px solid ${borderColor}`;
            box.style.backgroundColor = bgColor;
            box.style.borderRadius = '12px';
            box.style.pointerEvents = 'none';
            box.style.transition = 'all 0.2s ease-out';
            box.style.boxShadow = boxShadow;

            const [top, right, bottom, left] = face.location;

            const width = right - left;
            const height = bottom - top;
            const expandX = width * 0.2;
            const expandY = height * 0.2;

            const expandedLeft = Math.max(0, left - expandX);
            const expandedTop = Math.max(0, top - expandY);
            const expandedRight = Math.min(video.videoWidth, right + expandX);
            const expandedBottom = Math.min(video.videoHeight, bottom + expandY);

            const boxLeft = (expandedLeft * scaleX) + offsetX;
            const boxTop = (expandedTop * scaleY) + offsetY;
            const boxWidth = (expandedRight - expandedLeft) * scaleX;
            const boxHeight = (expandedBottom - expandedTop) * scaleY;

            box.style.left = boxLeft + 'px';
            box.style.top = boxTop + 'px';
            box.style.width = boxWidth + 'px';
            box.style.height = boxHeight + 'px';

            // Create label
            const label = document.createElement('div');
            label.style.position = 'absolute';
            label.style.top = '-35px';
            label.style.left = '0';
            label.style.backgroundColor = borderColor;
            label.style.color = 'white';
            label.style.padding = '6px 12px';
            label.style.fontSize = '14px';
            label.style.borderRadius = '6px';
            label.style.fontWeight = 'bold';
            label.style.whiteSpace = 'nowrap';
            label.style.boxShadow = '0 2px 4px rgba(0,0,0,0.3)';

            const icon = document.createElement('i');
            if (face.is_authorized) {
                icon.className = 'fas fa-check-circle';
            } else {
                icon.className = 'fas fa-exclamation-triangle';
            }
            icon.style.marginRight = '6px';
            label.appendChild(icon);

            const nameText = document.createTextNode(face.display_name || face.name);
            label.appendChild(nameText);

            // Distance badge
            const distanceBadge = document.createElement('div');
            distanceBadge.style.position = 'absolute';
            distanceBadge.style.bottom = '-30px';
            distanceBadge.style.left = '0';
            distanceBadge.style.backgroundColor = 'rgba(220, 38, 38, 0.9)';
            distanceBadge.style.color = 'white';
            distanceBadge.style.padding = '4px 10px';
            distanceBadge.style.fontSize = '12px';
            distanceBadge.style.borderRadius = '4px';
            distanceBadge.style.fontWeight = 'bold';
            distanceBadge.style.whiteSpace = 'nowrap';
            distanceBadge.style.boxShadow = '0 2px 4px rgba(0,0,0,0.3)';

            distanceBadge.innerHTML = `
            <i class="fas fa-ruler"></i> 
            ${face.distance_meters}m - CRITICAL DISTANCE
        `;

            box.appendChild(label);
            box.appendChild(distanceBadge);
            overlay.appendChild(box);
        });

        fpsCounter++;
    }

    function toggleDistanceSettings() {
        const panel = document.getElementById('distanceSettingsPanel');
        panel.classList.toggle('hidden');
    }

    function saveDistanceSettings() {
        const maxDistance = document.getElementById('maxDistance').value;

        const formData = new FormData();
        formData.append('max_distance', maxDistance);

        fetch('/api/update_distance_settings', {
            method: 'POST',
            body: formData
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('Distance settings updated successfully!');
                } else {
                    alert('Failed to update settings: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Error updating distance settings:', error);
                alert('Error updating distance settings');
            });
    }

    function loadDistanceSettings() {
        fetch('/api/get_distance_settings')
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    document.getElementById('maxDistance').value = data.settings.max_detection_distance;
                }
            })
            .catch(error => console.error('Error loading distance settings:', error));
    }

    function initializeOverlay() {
        const video = document.getElementById('videoElement');
        const overlay = document.getElementById('faceOverlay');

        const resizeOverlay = () => {
            const videoRect = video.getBoundingClientRect();
            overlay.style.width = videoRect.width + 'px';
            overlay.style.height = videoRect.height + 'px';
        };

        video.addEventListener('loadedmetadata', resizeOverlay);
        window.addEventListener('resize', resizeOverlay);
        resizeOverlay();
    }

    function takeScreenshot() {
        if (!cameraStream) {
            alert('Please start camera first');
            return;
        }

        const video = document.getElementById('videoElement');
        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0);

        canvas.toBlob(function (blob) {
            const formData = new FormData();
            formData.append('screenshot', blob, 'camera_capture_' + Date.now() + '.jpg');

            fetch('/api/save_screenshot', {
                method: 'POST',
                body: formData
            }).then(response => response.json())
                .then(data => {
                    if (data.success) {
                        alert('Screenshot saved successfully!');
                        loadRecentDetections();
                    } else {
                        alert('Failed to save screenshot: ' + (data.error || 'Unknown error'));
                    }
                });
        }, 'image/jpeg');
    }

    function toggleRecording() {
        if (!cameraStream) {
            alert('Please start camera first');
            return;
        }

        const button = document.getElementById('toggleRecording');

        if (isRecording) {
            fetch('/api/stop_recording', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        isRecording = false;
                        button.innerHTML = '<i class="fas fa-record-vinyl mr-1"></i>Start Recording';
                        button.className = 'bg-purple-600 hover:bg-purple-700 text-white px-3 py-2 rounded text-sm';
                        updateRecordingStatus('Stopped');
                    } else {
                        alert('Failed to stop recording: ' + (data.error || 'Unknown error'));
                    }
                });
        } else {
            fetch('/api/start_recording', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        isRecording = true;
                        button.innerHTML = '<i class="fas fa-stop mr-1"></i>Stop Recording';
                        button.className = 'bg-red-600 hover:bg-red-700 text-white px-3 py-2 rounded text-sm';
                        updateRecordingStatus('Recording');
                    } else {
                        alert('Failed to start recording: ' + (data.error || 'Unknown error'));
                    }
                });
        }
    }

    function toggleMotionDetection() {
        if (!cameraStream) {
            alert('Please start camera first');
            return;
        }

        const button = document.getElementById('toggleMotionDetection');

        if (motionDetectionActive) {
            stopMotionDetection();
            motionDetectionActive = false;
            button.innerHTML = '<i class="fas fa-running mr-1"></i>Start Motion';
            button.className = 'bg-yellow-600 hover:bg-yellow-700 text-white px-3 py-2 rounded text-sm';
            updateMotionDetectionStatus('Inactive');
        } else {
            startMotionDetection();
            motionDetectionActive = true;
            button.innerHTML = '<i class="fas fa-stop mr-1"></i>Stop Motion';
            button.className = 'bg-red-600 hover:bg-red-700 text-white px-3 py-2 rounded text-sm';
            updateMotionDetectionStatus('Active');
        }
    }

    function toggleFaceRecognition() {
        const button = document.getElementById('toggleFaceRecognition');

        if (faceRecognitionActive) {
            stopFaceRecognition();
            faceRecognitionActive = false;
            button.innerHTML = '<i class="fas fa-user-check mr-1"></i>Start Face Recognition';
            button.className = 'bg-indigo-600 hover:bg-indigo-700 text-white px-3 py-2 rounded text-sm';
            updateFaceRecognitionStatus('Inactive');
            document.getElementById('faceOverlay').innerHTML = '';
        } else {
            startFaceRecognition();
            faceRecognitionActive = true;
            button.innerHTML = '<i class="fas fa-stop mr-1"></i>Stop Face Recognition';
            button.className = 'bg-red-600 hover:bg-red-700 text-white px-3 py-2 rounded text-sm';
            updateFaceRecognitionStatus('Active');
        }
    }

    function playQuickMessage(messageType) {
        fetch('/api/dashboard_action', {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: `action=play_message&message_type=${messageType}`
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log('Message played:', data.result);
                } else {
                    console.error('Failed to play message:', data.error);
                }
            })
            .catch(error => console.error('Error playing message:', error));
    }

    function updateCameraStatus(status) {
        const element = document.getElementById('cameraStatus');
        element.textContent = status;
        element.className = status === 'Active' ?
            'bg-green-100 text-green-800 px-2 py-1 rounded text-sm' :
            'bg-red-100 text-red-800 px-2 py-1 rounded text-sm';
    }

    function updateRecordingStatus(status) {
        const element = document.getElementById('recordingStatus');
        element.textContent = status;
        element.className = status === 'Recording' ?
            'bg-green-100 text-green-800 px-2 py-1 rounded text-sm' :
            'bg-red-100 text-red-800 px-2 py-1 rounded text-sm';
    }

    function updateMotionDetectionStatus(status) {
        const element = document.getElementById('motionDetectionStatus');
        element.textContent = status;
        element.className = status === 'Active' ?
            'bg-green-100 text-green-800 px-2 py-1 rounded text-sm' :
            'bg-yellow-100 text-yellow-800 px-2 py-1 rounded text-sm';
    }

    function updateFaceRecognitionStatus(status) {
        const element = document.getElementById('faceRecognitionStatus');
        element.textContent = status;
        element.className = status === 'Active' ?
            'bg-green-100 text-green-800 px-2 py-1 rounded text-sm' :
            'bg-red-100 text-red-800 px-2 py-1 rounded text-sm';
    }

    function loadRecentDetections() {
        fetch('/api/unauthorized_detections')
            .then(response => response.json())
            .then(data => {
                const tbody = document.getElementById('detectionsTable');

                if (!data.success) {
                    tbody.innerHTML = `
                <tr>
                    <td colspan="5" class="px-4 py-4 text-center text-red-500">
                        <i class="fas fa-exclamation-triangle mr-2"></i>
                        Error loading alerts
                    </td>
                </tr>
            `;
                    return;
                }

                if (!data.detections || data.detections.length === 0) {
                    tbody.innerHTML = `
                <tr>
                    <td colspan="5" class="px-4 py-8 text-center text-gray-500">
                        <i class="fas fa-shield-check text-3xl mb-2 text-green-400"></i>
                        <p class="text-lg font-semibold">All Clear!</p>
                        <p class="text-sm mt-1">No security alerts detected</p>
                    </td>
                </tr>
            `;
                    return;
                }

                // ‚úÖ DEDUPLICATION: Group detections by person and type
                const uniqueDetections = new Map();

                data.detections.forEach(detection => {
                    // Create unique key: person_name + detection_type
                    const personName = (detection.person_name || 'Unknown').trim();
                    const detectionType = detection.type || 'unknown';
                    const key = `${personName}_${detectionType}`;

                    // Keep only most recent detection for each unique person+type
                    if (!uniqueDetections.has(key)) {
                        uniqueDetections.set(key, detection);
                    } else {
                        const existing = uniqueDetections.get(key);
                        const existingTime = new Date(existing.timestamp);
                        const newTime = new Date(detection.timestamp);

                        // Replace if this detection is more recent
                        if (newTime > existingTime) {
                            uniqueDetections.set(key, detection);
                        }
                    }
                });

                // Convert to array and sort by timestamp (most recent first)
                const filteredDetections = Array.from(uniqueDetections.values())
                    .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
                    .slice(0, 20); // Show max 20 unique detections

                tbody.innerHTML = '';

                // ‚úÖ DISPLAY: Show unique detections only
                filteredDetections.forEach(detection => {
                    const row = tbody.insertRow();
                    const timestamp = new Date(detection.timestamp).toLocaleString();
                    const isFaceDetection = detection.type === 'face_detection';

                    // ‚úÖ FIXED: Determine display based on category
                    const category = detection.category || 'other';
                    let displayName = detection.person_name || 'Unknown';
                    let typeClass = '';
                    let typeText = '';
                    let callIndicator = '';
                    let nameClass = '';

                    // ‚úÖ SET DISPLAY BASED ON CATEGORY
                    switch (category) {
                        case 'authorized':
                            typeClass = 'bg-green-100 text-green-800 border border-green-300';
                            typeText = 'Authorized Person';
                            callIndicator = '<span class="ml-2 text-xs bg-green-100 text-green-800 px-2 py-1 rounded">‚úÖ No Call</span>';
                            nameClass = 'text-green-600';
                            break;

                        case 'known':
                            typeClass = 'bg-blue-100 text-blue-800 border border-blue-300';
                            typeText = 'Known Person';
                            callIndicator = '<span class="ml-2 text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded">üëã No Call</span>';
                            nameClass = 'text-blue-600';
                            break;

                        case 'unauthorized':
                            typeClass = 'bg-red-100 text-red-800 border border-red-300';
                            typeText = 'Unauthorized';
                            callIndicator = isFaceDetection ?
                                '<span class="ml-2 text-xs bg-red-100 text-red-800 px-2 py-1 rounded">üìû Call Triggered</span>' :
                                '<span class="ml-2 text-xs bg-orange-100 text-orange-800 px-2 py-1 rounded">‚ö†Ô∏è Alert Only</span>';
                            nameClass = 'text-red-600';
                            break;

                        case 'motion':
                            typeClass = 'bg-orange-100 text-orange-800 border border-orange-300';
                            typeText = 'Motion Detected';
                            callIndicator = '<span class="ml-2 text-xs bg-orange-100 text-orange-800 px-2 py-1 rounded">üìπ Recording</span>';
                            nameClass = 'text-orange-600';
                            break;

                        default:
                            typeClass = 'bg-gray-100 text-gray-800 border border-gray-300';
                            typeText = detection.type.replace('_', ' ') || 'Detection';
                            callIndicator = '<span class="ml-2 text-xs bg-gray-100 text-gray-600 px-2 py-1 rounded">üìã Logged</span>';
                            nameClass = 'text-gray-600';
                    }

                    let confidenceDisplay = 'N/A';
                    if (detection.confidence !== null && detection.confidence !== undefined) {
                        confidenceDisplay = (detection.confidence * 100).toFixed(1) + '%';
                    }

                    // ‚úÖ COMBINED: Actions column with icon buttons
                    row.innerHTML = `
                <td class="px-4 py-2 text-sm">${timestamp}</td>
                <td class="px-4 py-2">
                    <span class="px-2 py-1 rounded text-sm ${typeClass}">
                        ${typeText}
                    </span>
                    ${callIndicator}
                </td>
                <td class="px-4 py-2 font-semibold ${nameClass}">
                    ${displayName}
                </td>
                <td class="px-4 py-2">
                    <span class="px-2 py-1 bg-gray-100 rounded text-xs font-mono">
                        ${confidenceDisplay}
                    </span>
                </td>
                <td class="px-4 py-2">
                    <div class="flex flex-col space-y-2">
                        <a href="{{ url_for('alerts') }}" 
                           class="bg-red-600 hover:bg-red-700 text-white p-2 rounded text-sm inline-flex items-center justify-center transition-colors duration-200"
                           title="Review Alert">
                            <i class="fas fa-bell"></i>
                        </a>
                        ${detection.screenshot_path ?
                            `<a href="/${detection.screenshot_path}" target="_blank" 
                                class="bg-blue-600 hover:bg-blue-700 text-white p-2 rounded text-sm inline-flex items-center justify-center transition-colors duration-200"
                                title="View Image">
                                <i class="fas fa-image"></i>
                            </a>` :
                            `<button class="bg-gray-400 cursor-not-allowed text-white p-2 rounded text-sm inline-flex items-center justify-center"
                                title="No Image Available" disabled>
                                <i class="fas fa-image"></i>
                            </button>`
                        }
                    </div>
                </td>
            `;
                });

                // ‚úÖ STATS UPDATE: Show unique count
                const uniqueCount = filteredDetections.length;
                console.log(`üìä Showing ${uniqueCount} unique detections (deduplicated from ${data.detections.length} total)`);
            })
            .catch(error => {
                console.error('Error loading alerts:', error);
                const tbody = document.getElementById('detectionsTable');
                tbody.innerHTML = `
            <tr>
                <td colspan="5" class="px-4 py-4 text-center text-red-500">
                    Network error loading alerts
                </td>
            </tr>
        `;
            });
    }

    // Make sure this function exists
    function getAlertLevelClass(level) {
        switch (level) {
            case 1: return 'bg-green-100 text-green-800 border border-green-200';
            case 2: return 'bg-yellow-100 text-yellow-800 border border-yellow-200';
            case 3: return 'bg-red-100 text-red-800 border border-red-200';
            default: return 'bg-gray-100 text-gray-800 border border-gray-200';
        }
    }

    document.addEventListener('DOMContentLoaded', function () {
        loadRecentDetections();
    });

    setInterval(loadRecentDetections, 10000);


    function toggleMotionDetection() {
        if (!cameraStream) {
            alert('Please start camera first');
            return;
        }

        const action = motionDetectionActive ? 'stop_motion_detection' : 'start_motion_detection';

        fetch('/api/dashboard_action', {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: `action=${action}`
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    motionDetectionActive = !motionDetectionActive;
                    updateMotionDetectionStatus(motionDetectionActive ? 'Active' : 'Inactive');

                    if (motionDetectionActive) {
                        startMotionDetection();
                    } else {
                        stopMotionDetection();
                    }
                }
            });
    }

    function startMotionDetection() {
        if (motionDetectionInterval) return;

        console.log('Starting motion detection');
        motionDetectionInterval = setInterval(() => {
            detectMotion();
        }, 1000); // Detect every second
    }

    function stopMotionDetection() {
        if (motionDetectionInterval) {
            clearInterval(motionDetectionInterval);
            motionDetectionInterval = null;
        }
    }

    // Make sure this function exists
    function getAlertLevelClass(level) {
        switch (level) {
            case 1: return 'bg-green-100 text-green-800 border border-green-200';
            case 2: return 'bg-yellow-100 text-yellow-800 border border-yellow-200';
            case 3: return 'bg-red-100 text-red-800 border border-red-200';
            default: return 'bg-gray-100 text-gray-800 border border-gray-200';
        }
    }

    document.addEventListener('DOMContentLoaded', function () {
        loadRecentDetections();
        setInterval(loadRecentDetections, 10000); // Refresh every 10 seconds
    });

    setInterval(loadRecentDetections, 10000);


    function toggleMotionDetection() {
        if (!cameraStream) {
            alert('Please start camera first');
            return;
        }

        const action = motionDetectionActive ? 'stop_motion_detection' : 'start_motion_detection';

        fetch('/api/dashboard_action', {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: `action = ${action} `
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    motionDetectionActive = !motionDetectionActive;
                    updateMotionDetectionStatus(motionDetectionActive ? 'Active' : 'Inactive');

                    if (motionDetectionActive) {
                        startMotionDetection();
                    } else {
                        stopMotionDetection();
                    }
                }
            });
    }

    function startMotionDetection() {
        if (motionDetectionInterval) return;

        console.log('Starting motion detection');
        motionDetectionInterval = setInterval(() => {
            detectMotion();
        }, 1000); // Detect every second
    }

    function stopMotionDetection() {
        if (motionDetectionInterval) {
            clearInterval(motionDetectionInterval);
            motionDetectionInterval = null;
            document.getElementById('motionOverlay').innerHTML = '';
            console.log('Motion detection stopped');
        }
    }

    function detectMotion() {
        const video = document.getElementById('videoElement');
        if (!video.srcObject || video.readyState !== video.HAVE_ENOUGH_DATA) return;

        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0);

        const imageData = canvas.toDataURL('image/jpeg');

        const formData = new FormData();
        formData.append('image_data', imageData);

        fetch('/api/detect_motion', {
            method: 'POST',
            body: formData
        })
            .then(response => response.json())
            .then(data => {
                if (data.success && data.motion_detected) {
                    // Update human motiofn status if available
                    if (data.human_detected !== undefined) {
                        updateHumanMotionStatus(data.human_detected);
                    }
                } else {
                    document.getElementById('motionOverlay').innerHTML = '';
                }
            })
            .catch(error => console.error('Motion detection error:', error));
    }

    // Helper function to update human motion status
    function updateHumanMotionStatus(humanDetected) {
        if (humanDetected) {
            console.log('Human motion detected - enabling face detection');
            // You can add visual indicators here if needed
        }
    }

    function displayMotionDetections(detections) {
        const overlay = document.getElementById('motionOverlay');
        const video = document.getElementById('videoElement');

        overlay.innerHTML = '';

        detections.forEach(detection => {
            // ONLY display animal detections, NOT human detections
            if (detection.type === 'animal') {
                const box = document.createElement('div');
                box.style.position = 'absolute';
                box.style.border = '3px solid #D97706'; // Amber for animals
                box.style.backgroundColor = 'rgba(217, 119, 6, 0.15)';
                box.style.borderRadius = '8px';
                box.style.pointerEvents = 'none';
                box.style.transition = 'all 0.3s ease-out';
                box.style.boxShadow = '0 0 10px rgba(217, 119, 6, 0.5)';

                const videoRect = video.getBoundingClientRect();
                const scaleX = videoRect.width / video.videoWidth;
                const scaleY = videoRect.height / video.videoHeight;

                const [x, y, w, h] = detection.bbox;
                box.style.left = (x * scaleX) + 'px';
                box.style.top = (y * scaleY) + 'px';
                box.style.width = (w * scaleX) + 'px';
                box.style.height = (h * scaleY) + 'px';

                const label = document.createElement('div');
                label.style.position = 'absolute';
                label.style.top = '-35px';
                label.style.left = '0';
                label.style.backgroundColor = '#D97706';
                label.style.color = 'white';
                label.style.padding = '4px 8px';
                label.style.fontSize = '12px';
                label.style.borderRadius = '4px';
                label.style.fontWeight = 'bold';
                label.style.pointerEvents = 'none';
                label.style.whiteSpace = 'nowrap';
                label.style.boxShadow = '0 2px 4px rgba(0,0,0,0.2)';
                label.innerHTML = `
                        <i i class="fas fa-paw mr-1" ></i >
                            ANIMAL(${(detection.confidence * 100).toFixed(0)}%)
                    `;

                box.appendChild(label);
                overlay.appendChild(box);
            }
            // Human detections are NOT displayed with boxes
        });
    }


    function updateMotionDetectionStatus(status) {
        const element = document.getElementById('motionDetectionStatus');
        element.textContent = status;
        element.className = status === 'Active' ?
            'bg-green-100 text-green-800 px-2 py-1 rounded text-sm' :
            'bg-yellow-100 text-yellow-800 px-2 py-1 rounded text-sm';

        // Update the toggle button
        const button = document.getElementById('toggleMotionDetection');
        if (status === 'Active') {
            button.innerHTML = '<i class="fas fa-stop mr-1"></i>Stop Motion';
            button.className = 'bg-red-600 hover:bg-red-700 text-white px-3 py-2 rounded text-sm';
        } else {
            button.innerHTML = '<i class="fas fa-running mr-1"></i>Motion Detection';
            button.className = 'bg-yellow-600 hover:bg-yellow-700 text-white px-3 py-2 rounded text-sm';
        }
    }

    function updateDebugPanel(motionStatus) {
        if (!motionStatus) return;

        document.getElementById('debugHumanMotion').textContent = motionStatus.human_motion_detected ? 'YES' : 'NO';
        document.getElementById('debugHumanMotion').className = motionStatus.human_motion_detected ?
            'font-bold text-green-600' : 'font-bold text-red-600';

        document.getElementById('debugFaceDetection').textContent = motionStatus.face_detection_enabled ? 'YES' : 'NO';
        document.getElementById('debugFaceDetection').className = motionStatus.face_detection_enabled ?
            'font-bold text-green-600' : 'font-bold text-red-600';

        // Update step 3 status
        const step3 = document.getElementById('faceDetectionStep');
        if (motionStatus.face_detection_enabled) {
            step3.innerHTML = `
                    <div div class="w-6 h-6 rounded-full bg-green-500 flex items-center justify-center text-white text-xs font-bold" > 3</div >
                        <span class="text-green-600"><strong>Face Detection:</strong> ACTIVE - Human detected within critical distance</span>
                `;
        } else {
            step3.innerHTML = `
                    <div div class="w-6 h-6 rounded-full bg-gray-400 flex items-center justify-center text-white text-xs font-bold" > 3</div >
                        <span class="text-gray-600"><strong>Face Detection:</strong> INACTIVE - Waiting for human motion within 1.5m</span>
        `;
        }
    }

    function clearUnauthorizedCache() {
        fetch('/api/clear_unauthorized_cache', { method: 'POST' })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert(data.message);
                    document.getElementById('debugCachedFaces').textContent = '0';
                }
            });
    }

    // Face tracking management functions

    function refreshFaceTracking() {
        fetch('/api/face_tracking_stats')
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    const stats = data.stats;

                    // ‚úÖ SAFE ELEMENT UPDATES:
                    const trackedFacesElement = document.getElementById('trackedFacesCount');
                    const answeredCallsElement = document.getElementById('answeredCallsCount');
                    const cooldownElement = document.getElementById('cooldownTime');
                    const maxCallsElement = document.getElementById('maxCallsPerFace');

                    if (trackedFacesElement) trackedFacesElement.textContent = stats.total_tracked_faces || 0;
                    if (answeredCallsElement) answeredCallsElement.textContent = stats.total_answered_faces || 0;
                    if (cooldownElement) cooldownElement.textContent = formatTime(stats.alert_cooldown_seconds);
                    if (maxCallsElement) maxCallsElement.textContent = stats.max_alerts_per_face;

                    displayTrackedFaces(stats.tracked_faces || []);
                }
            })
            .catch(error => console.error('Error loading face tracking stats:', error));
    }

    function displayTrackedFaces(faces) {
        const tbody = document.getElementById('trackedFacesTable');

        if (!tbody) {
            console.error('Tracked faces table not found');
            return;
        }

        if (!faces || faces.length === 0) {
            tbody.innerHTML = `
            <tr>
                <td colspan="6" class="px-4 py-4 text-center text-gray-500">
                    <i class="fas fa-check-circle text-green-400 mr-2"></i>
                    No faces currently tracked - all clear!
                </td>
            </tr>
        `;
            return;
        }

        tbody.innerHTML = '';

        faces.forEach(face => {
            const row = tbody.insertRow();

            let statusHTML, statusClass, callStatus;

            if (face.answered) {
                statusHTML = '<i class="fas fa-phone-slash mr-1"></i>Answered';
                statusClass = 'bg-green-100 text-green-800';
                callStatus = 'No more calls';
            } else if (face.alert_count >= 3) {
                statusHTML = '<i class="fas fa-ban mr-1"></i>Max Reached';
                statusClass = 'bg-red-100 text-red-800';
                callStatus = 'No more calls';
            } else if (face.time_until_reset > 0) {
                statusHTML = '<i class="fas fa-clock mr-1"></i>Cooldown';
                statusClass = 'bg-yellow-100 text-yellow-800';
                callStatus = `${face.time_until_reset}s until next call`;
            } else {
                statusHTML = '<i class="fas fa-phone mr-1"></i>Can Call';
                statusClass = 'bg-blue-100 text-blue-800';
                callStatus = `Next call ready (${face.alert_count || 0}/3)`;
            }

            row.innerHTML = `
            <td class="px-4 py-2 font-mono text-sm">${face.face_id}</td>
            <td class="px-4 py-2">
                <span class="px-2 py-1 bg-gray-100 rounded">
                    ${face.alert_count || 0} / 3
                </span>
            </td>
            <td class="px-4 py-2 text-sm">${face.last_alert_seconds_ago ? formatTime(face.last_alert_seconds_ago) + ' ago' : 'Never'}</td>
            <td class="px-4 py-2 text-sm">${callStatus}</td>
            <td class="px-4 py-2">
                <span class="px-2 py-1 rounded text-xs ${statusClass}">
                    ${statusHTML}
                </span>
            </td>
            <td class="px-4 py-2">
                ${face.answered ?
                    '<button onclick="resetFaceCall(\'' + face.face_id + '\')" class="text-xs bg-gray-500 hover:bg-gray-600 text-white px-2 py-1 rounded">Reset</button>' :
                    ''
                }
            </td>
        `;
        });
    }

    function formatTime(seconds) {
        if (seconds < 60) {
            return `${seconds}s`;
        } else if (seconds < 3600) {
            const minutes = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${minutes}:${secs.toString().padStart(2, '0')}`;
        } else {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            return `${hours}h ${minutes}m`;
        }
    }

    function cleanupOldFaces() {
        if (confirm('Remove face tracking for faces older than 24 hours?')) {
            fetch('/api/cleanup_face_tracking', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: 'hours=24'
            })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        alert(`‚úÖ Cleaned up ${data.cleaned_count} old faces`);
                        refreshFaceTracking();
                    } else {
                        alert('‚ùå Cleanup failed: ' + data.error);
                    }
                });
        }
    }

    function resetFaceTracking() {
        if (confirm('‚ö†Ô∏è Reset ALL face tracking? This will allow all faces to trigger alerts again.')) {
            fetch('/api/reset_face_tracking', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        alert('‚úÖ ' + data.message);
                        refreshFaceTracking();
                    } else {
                        alert('‚ùå Reset failed: ' + data.error);
                    }
                });
        }
    }

    // Auto-refresh every 30 seconds
    setInterval(refreshFaceTracking, 30000);

    // Initial load
    document.addEventListener('DOMContentLoaded', function () {
        refreshFaceTracking();
    });
</script>
{% endblock %}